---
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    bookdown::html_document2:
      number_sections: yes
bibliography: Roads.bib
csl: "../templates/canadian-journal-of-forest-research.csl" # Insert path for the bib-style

editor_options: 
  chunk_output_type: inline
---

# (APPENDIX) Supplementary Material for Implementation and assessment of tools for integrating forest roads into projections of the cumulative effects of disturbance on wildlife {-}

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  comment = "#>",
  fig.path = "../figures/",
  dpi = 300
)
```

```{r setup2}
library(ggplot2)
library(dplyr)
library(stringr)
library(tidyr)
library(purrr)
library(ggpubr)
library(MetBrewer)
library(here)
library(tmap)
library(sf)

devtools::load_all(here())

#set paths
data_path_raw <- "analysis/data/raw_data/"
data_path_drvd <- "analysis/data/derived_data/TSA27"

pal_nm <- "Redon"

fig_widths <- c(min = 1.18, single = 3.543, mid = 5.51, two = 7.48)

```

# All cutblocks results

```{r aspat-perf-fig-all, fig.height=4, fig.width=fig_widths["two"], fig.cap="Proportional difference of projected mean from observed mean road metrics using different projection method variants with a 1 ha resolution cost raster. Metrics were summarised within cutblocks, outside cutblocks, and overall. Values greater than 0 indicate overprojection of the metric and negative values indicate an underprojection. Cutblocks included all cutblocks present in the harvest dataset including falsly detected cutblocks with no observed roads accessing them."}
meanTable <- read.csv(here(data_path_drvd, "dem", "mean_table.csv"))
doAspatPlot(meanTable)
```

```{r spat-perf-fig-all, fig.height=4.5, fig.width=fig_widths["two"], fig.cap="Comparison of performance metrics for each projection method variant using the 1 ha resolution cost raster. F-measure is the harmonic mean of precision and sensitivity, precision is the proportion of predicted roads that are observed roads and sensitivity is the proportion of observed roads that were correctly predicted. Values closer to one indicate better performance. Cutblocks included all cutblocks present in the harvest dataset including falsly detected cutblocks with no observed roads accessing them."}
matchData <- read.csv(here(data_path_drvd, "dem", "agree_table.csv"))
perf_tbl2 <- doSpatPerf(matchData)
doSpatPlot(perf_tbl2)

```

# Coarse resolution results

```{r get-data2}
data_path_drvd <- "analysis/data/derived_data/TSA27_real_cuts/"

# load csv
meanTable2 <- read.csv(here(data_path_drvd, "dem_1000", "mean_table.csv")) %>% 
  mutate(resolution = "1000")

matchData2 <- read.csv(here(data_path_drvd, "dem_1000", "agree_table.csv")) %>% 
  mutate(resolution = "1000")

# compare to real cuts
meanTable <- read.csv(here(data_path_drvd, "dem", "mean_table.csv"))
meanTable <- meanTable %>% mutate(resolution = "100") %>% bind_rows(meanTable2) %>% 
  filter((method != "ilcp"| is.na(method)) & (sampleType != "cutOnly" | is.na(sampleType)))

matchData <- read.csv(here(data_path_drvd, "dem", "agree_table.csv"))
matchData <- matchData %>% mutate(resolution = "100") %>% bind_rows(matchData2) %>% 
  filter(method != "ilcp", sampleType != "cutOnly")

```

```{r figA1, fig.height=6, fig.width=fig_widths["two"], fig.cap="Proportional difference of projected mean from observed mean road metrics using different projection methods for the fine resolutiom (1 ha) and coarse resolution (100 ha) cost rasters. Metrics were summarised within cutblocks, outside cutblocks, and overall. Values greater than 0 indicate the projection overestimated the metric and negative values indicate an underestimation."}
# organize data for ggplot
meanTable_long <- meanTable %>% dplyr::select(-runTime, -order) %>% 
  pivot_longer(-c(sampleType, sampleDens, areaMean, resolution, method),
               names_to = "metric", values_to = "response")%>%
  mutate(sampleType = ifelse(sampleType == sampleDens, NA_character_, 
                             sampleType),
         sampleDens = paste(method, sampleType, sampleDens) %>% 
           factor(levels = c("mst NA centroid",
                             "NA NA observed",
                             "mst random low sample density",
                             "mst regular low sample density",
                             "mst random high sample density",
                             "mst regular high sample density",
                             "ilcp regular high sample density",
                             "NA klementQGIS", 
                             "NA NA NA"),
                  labels = c("MST centroid", 
                             "Observed",
                             "MST random low density",
                             "MST regular low density",
                             "MST random high density",
                             "MST regular high density",
                             "ILCP regular high density",
                             "Hardy QGIS",
                             "Cutblocks only")),
         metric = factor(metric,
                         levels = c("roadDensityMean", "roadPresenceMean",
                                    "distanceToRoadMean",
                                    "forestryDisturbanceMean",
                                    "roadDisturbanceMean"),
                         labels = c("Road\ndensity", "Road\npresence",
                                    "Distance\nto road",
                                    "Forestry\ndisturbance\nfootprint",
                                    "Road\ndisturbance\nfootprint")))

observed_values <- filter(meanTable_long, sampleDens == "Observed")
projected_values <- filter(meanTable_long, sampleDens != "Observed")

# get proportional difference from observed
prop_dif <- projected_values %>% 
  left_join(observed_values %>% select(areaMean, metric, resolution, response),
            by = c("areaMean", "metric", "resolution"), 
            suffix = c("_proj", "_obs")) %>% 
  mutate(prop_dif = (response_proj-response_obs)/response_obs,
         areaMean = factor(areaMean, labels = c("Cutblocks", "Outside\ncutblocks",
                                                "Overall")))

prop_dif %>% 
  ggplot(aes(x = sampleDens, prop_dif, fill = resolution))+
  geom_hline(aes(yintercept = 0), color = "grey")+
  geom_col(position = position_dodge2(preserve = "single",
                                      width = 0.75))+
  facet_grid(areaMean ~ metric, scales = "free")+
  theme_classic()+
  scale_fill_manual(values = met.brewer(pal_nm), labels = c("1 ha", "100 ha"))+
  theme(text = element_text(size = 10), axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "right",
        axis.text.x=element_text(size=11, angle=50, vjust=1, hjust=1))+
  coord_flip()+
  labs(fill = "Resolution")

```

```{r figA2, fig.height=4.5, fig.width=fig_widths["two"], fig.cap="Comparison of performance metrics for each projection method variant for the fine resolutiom (1 ha) and coarse resolution (100 ha) cost rasters. F measure is the harmonic mean of precision and sensitivity, precision is the proportion of predicted roads that are observed roads and sensitivity is the proportion of observed roads that were correctly predicted."}

matchData_sum <- matchData %>% ungroup() %>%
  mutate(agreement = factor(agreement,
                            levels = c("False negative", "False positive",
                                       "Agree roaded","Agree roadless",
                                       "Pre-existing roads")),
         sampleDens = paste(method, sampleType, sampleDens) %>%
           str_replace("1e-06", "low density") %>%
           str_replace("1e-05", "high density") %>%
           str_replace("centroid low density", "centroid") %>%
           str_replace("klementQGIS NA", "klementQGIS") %>%
           factor(levels = c("mst centroid",
                             "mst random low density",
                             "mst regular low density",
                             "mst random high density",
                             "mst regular high density",
                             "ilcp regular high density",
                             "NA klementQGIS"),
                  labels = c("MST centroid", 
                             "Random low density",
                             "Regular low density",
                             "Random high density",
                             "Regular high density",
                             "ILCP regular high density",
                             "Hardy QGIS")),
         metric = factor(metric,
                         levels = c("roadPresence",
                                    "forestryDisturbance",
                                    "roadDisturbance"),
                         labels = c("Road presence",
                                    "Forestry disturbance\nfootprint",
                                    "Road disturbance\nfootprint"))) %>%
  group_by(metric, sampleDens, agreement, resolution) %>%
  summarise(count = sum(count), .groups = "drop_last") %>%
  mutate(perc = count/sum(count)*100)

# performance table
perf_tbl <- matchData_sum %>% 
  pivot_wider(c(metric, sampleDens, resolution), names_from = agreement, 
              values_from = count) %>% 
  mutate(sensitivity = `Agree roaded`/(`Agree roaded` + `False negative`),
         precision = `Agree roaded`/(`Agree roaded` + `False positive`),
         F_measure = (2*precision*sensitivity)/(precision+sensitivity)) %>% 
  select(resolution, metric, sampleDens, sensitivity, precision, F_measure) 

perf_tbl_rng <- perf_tbl %>% group_by(metric, resolution) %>% 
  summarise(rng_F = range(F_measure) %>% round(3) %>% paste0(collapse = " - "), .groups = "drop") %>% pull(rng_F, name = metric)

perf_tbl %>% 
  pivot_longer(c(sensitivity, precision, F_measure), names_to = "perf_meas",
               values_to = "value") %>% 
  mutate(perf_meas = factor(perf_meas,
                            labels = c("F measure", "Precision", "Sensitivity"))) %>% 
  ggplot(aes(sampleDens, value, fill = resolution))+
  geom_col(position = position_dodge2(preserve = "single",
                                      width = 0.75))+
  scale_fill_manual(values = met.brewer(pal_nm), labels = c("1 ha", "100 ha"))+
  facet_grid(metric ~ perf_meas)+
  coord_flip()+
  scale_y_continuous(limits = c(0, 1), breaks = 0:5/5)+
  theme_classic()+
  labs(y = "Performance", x = NULL, fill = "Resolution")

```

# Fort Nelson map

```{r ftNelson, cache=TRUE, fig.height=6, fig.width=fig_widths["two"], fig.cap="Existing roads in Fort Nelson. Cost based road projection methods are not expected to be useful in areas where roads are built for purposes other than accessing a target location at minimal cost. For example, in the Northeast corner of the Fort Nelson Timber Supply Area seismic lines show a different pattern than foresty roads."}
ftN_roads_obs <- read_sf(here("analysis/data/derived_data/combined_ft_nelson_roads.gpkg"))

# only show top right corner
bb <- st_bbox(ftN_roads_obs) 

bb[["xmin"]] <- bb[["xmax"]] - (bb[["xmax"]] - bb[["xmin"]])/2
bb[["ymin"]] <- bb[["ymax"]] - (bb[["ymax"]] - bb[["ymin"]])/2

ftN_roads_obs_NE <- st_crop(ftN_roads_obs, bb)

tm_shape(ftN_roads_obs_NE, is.master = TRUE)+
  tm_lines()
```

\newpage

# Colophon

This report was generated on `r Sys.time()` using the following computational environment and dependencies:

```{r colophon, cache = FALSE}
# which R packages and versions?
#if ("devtools" %in% installed.packages()) devtools::session_info()
```

The current Git commit details are:

```{r}
# what commit is this file at? 
#if ("git2r" %in% installed.packages() & git2r::in_repository(path = ".")) git2r::repository(here::here())  
```
